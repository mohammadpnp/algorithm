<div dir="rtl">

# درسنامه: Binary Search (روی داده و روی پاسخ)

## ایده اصلی

جستجوی دودویی فقط برای یافتن عدد در آرایه مرتب نیست.
هر جا تابعی monotonic باشد، می‌توانی روی فضای جواب binary search بزنی.

## سیگنال‌های تشخیص

1. "کمترین/بیشترین مقدار که شرطی را ارضا کند"
2. تابع امکان‌سنجی yes/no با رفتار monotonic
3. فضای پاسخ عددی بزرگ و brute force کند

## الگوهای مهم

### 1) Binary Search کلاسیک روی آرایه مرتب

- دنبال exact match یا lower/upper bound

### 2) Binary Search روی Answer

- `lo` و `hi` را روی دامنه جواب می‌گیری
- تابع `can(mid)` می‌گوید شدنی هست یا نه
- اگر شدنی بود سمت چپ/راست می‌روی بسته به نوع هدف

## قالب ذهنی

```text
lo, hi := minAnswer, maxAnswer
for lo < hi:
    mid = lo + (hi-lo)/2
    if can(mid):
        hi = mid      // برای کمینه جواب شدنی
    else:
        lo = mid + 1
return lo
```

## پیچیدگی

- زمان: `O(log range * cost(can))`
- حافظه: معمولاً `O(1)`

## اشتباهات رایج

1. تعیین اشتباه بازه اولیه `lo/hi`
2. loop بی‌نهایت به خاطر آپدیت غلط مرزها
3. اشتباه در `mid` و overflow (در Go کمتر مسئله است ولی بهتر است safe بنویسی)
4. تعریف ناقص `can` (به‌خصوص edge caseها)

## مثال عملی کوتاه

مسئله: حداقل سرعتی که بتوانی کارها را در `h` ساعت تمام کنی.

- اگر با سرعت `x` شدنی باشد، با سرعت بالاتر هم شدنی است.
- پس monotonic برقرار است.

## نکته مصاحبه

حتماً monotonic بودن را شفاهی اثبات کن. این بخش معمولاً معیار اصلی درک تو از مسئله است.

</div>
